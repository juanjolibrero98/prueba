{"ast":null,"code":"import { environment } from '@environments/environment';\nimport { checkToken } from '@interceptors/token.interceptor';\nimport { BehaviorSubject } from 'rxjs';\nimport * as i0 from \"@angular/core\";\nimport * as i1 from \"@angular/common/http\";\nexport let BoardsService = /*#__PURE__*/(() => {\n  class BoardsService {\n    constructor(http) {\n      this.http = http;\n      this.apiUrl = environment.API_URL;\n      this.bufferSpace = 65535; //variable para pasar el background color del board al navbar para que coja el mismo color\n\n      this.backgroundColorBoard$ = new BehaviorSubject('sky');\n    }\n\n    getBoard(id) {\n      return this.http.get(`${this.apiUrl}/api/v1/boards/${id}`, {\n        context: checkToken()\n      });\n    } //metodo para calcular la posicion de las cartas(cada una de las tareas)\n    //devuelve la lista[] con las posiciones en las que se ha quedado cada card y la posicion: number en la que se ha quedado el elemento movido en esa lista\n\n\n    getPosition(cards, currentIndex) {\n      console.log(cards, currentIndex);\n\n      if (cards.length === 1) {\n        //si una card es nueva en la lista (is new)\n        return this.bufferSpace;\n      }\n\n      if (cards.length > 1 && currentIndex === 0) {\n        //si una card esta en lo mas alto de la lista (is the top)\n        const onTopPosition = cards[1].position; //card que se encuentra arriba de la que se ha movido\n\n        return onTopPosition / 2;\n      }\n\n      const lastIndex = cards.length - 1;\n\n      if (cards.length > 2 && currentIndex > 0 && currentIndex < lastIndex) {\n        //si una card esta en medio de la lista (is the middle)\n        const prevPosition = cards[currentIndex - 1].position;\n        const nextPosition = cards[currentIndex + 1].position;\n        return (prevPosition + nextPosition) / 2; //promedio de las cards\n      }\n\n      if (cards.length > 1 && currentIndex === lastIndex) {\n        //si una card esta en lo mas bajo de la lista (is the bottom)\n        const onBottomPosition = cards[lastIndex - 1].position;\n        return onBottomPosition + this.bufferSpace;\n      }\n\n      return 0;\n    }\n\n    createBoard(title, backgroundColor) {\n      return this.http.post(`${this.apiUrl}/api/v1/boards`, {\n        title,\n        backgroundColor\n      }, {\n        context: checkToken()\n      });\n    } //metodo para calcular donde se debe añadir una nueva card o una nueva lista\n\n\n    getPositionNewCardOrList(elements) {\n      if (elements.length === 0) {\n        //si la lista o el board no tiene elemento que se añada 1º\n        return this.bufferSpace;\n      }\n\n      const lastIndex = elements.length - 1; //si la lista o el board tiene elementos que se ponga el ultimo\n\n      const onBottomPosition = elements[lastIndex].position;\n      return onBottomPosition + this.bufferSpace;\n    } //metodo para recuperar el background color del board y guardarlo en la variable\n\n\n    setBackgroundColor(color) {\n      this.backgroundColorBoard$.next(color);\n    } //metodo para recuperar el background color del board\n\n\n    getBackgroundColor() {\n      return this.backgroundColorBoard$;\n    } //actualizar el board\n\n\n    updateBoard(id, title, backgroundColor) {\n      return this.http.put(`${this.apiUrl}/api/v1/boards/${id}`, {\n        title,\n        backgroundColor\n      }, {\n        context: checkToken()\n      });\n    }\n\n  }\n\n  BoardsService.ɵfac = function BoardsService_Factory(t) {\n    return new (t || BoardsService)(i0.ɵɵinject(i1.HttpClient));\n  };\n\n  BoardsService.ɵprov = /*@__PURE__*/i0.ɵɵdefineInjectable({\n    token: BoardsService,\n    factory: BoardsService.ɵfac,\n    providedIn: 'root'\n  });\n  return BoardsService;\n})();","map":null,"metadata":{},"sourceType":"module"}